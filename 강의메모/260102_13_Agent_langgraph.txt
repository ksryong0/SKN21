MCP 구성요소
호스트
클라이언트
서버

MCP서버가 제공
도구
리소스
프롬프트

mcp 서버가 툴들을 들고있는것.

"/Users/username/Desktop"
/path/to/other/allowed/dir

--------------복습-----------

mcp 코드(mcp_exam.py)는 도커 켜야 잘됨.

-------------------------------
랭그래프

선형적인 흐름이 아님. 선형적인건 랭체인.
ReAct
생각-행동-관찰
반복. 원하는결과가 나올때까지.

ReAct패턴을 어떻게 만족할까에서 나온거.

노드와 노드간의 관계 연결:엣지

그래프는 방향성이 있는거랑 없는거 두가지가 있음.

노드:기능. 어떤 일을 하는 애들.

노드:기능. ------------------- 노드:기능
               엣지:일의흐름

분기,병렬,반복 구조를 다룰 수 있음.

상태 유지. 일이 시작해서 끝날때까지 유지되는 데이터. 영구적이지는 않음. 상태는 딕셔너리로 만듬

에이전트 하나에 llm을 붙였을 때, LLm에 붙일수있는 툴들이 너무 많으면, LLM이 툴들을 모두 컨트롤할 수 없음. 그래서 에이전트와 LLM을 여러개 씀 => 멀티에이전트. 역할에 따라 분류.

도구호출을 low level(직접 만들어야되는거) 에서 제어.
high level은 추상화된거, 만들어져 있는 거.

노드는 기능인데 툴하고 다름. 노드가 LLM일수도 있음. 동작을 하는 애들. 함수로 구현.

엣지:어떤 연결인지 정보를 갖고 있는거. 어떤 식으로 흐름을 제어할지에 대한 내용을 가짐. 엣지를 함수로 만들기도 함.

랭체인은 직렬구조.
랭그래프는 
	스테이트가 따로 있음. 
스테이트?
스테이트는 엣지를 통해 노드들과 연결해둠. 노드들 각각이 일이 끝나면 스테이트를 업데이트하고, 업데이트된 스테이트로 다른 노드를 호출할때, 그 정보를 알려줌. 스테이트를 노드별로 독립적으로 넣어놓고, 공유함. 한군데에 모아둠. 공유장소 역할을 하는게 스테이트. 딕셔너리로 관리. 개인적으로는 LLM으로 크리스마스 이미지 만들기 이벤트 같음. 앞에서 처리한걸 뒤에서 가져다 쓰는것도 가능.
스테이트의 딕셔너리는 미리 정의되어 있어야 함.
주요역할
전체 워크플로우의 컨텍스트 유지
노드간 정보 공유.
진행 상황 추적:특정 시점에 사람의 승인을 기다림.(HITL:Human In The Loop)

# 랭그래프 설치
!uv pip install langgraph

흐름
state:빈 딕셔너리
invoke에서 보내준게 추가됨. save_path
add_name은 save_path를 받아서, name은 홍길동이야 리턴.
그럼 state에 save_path에 name은 홍길동이야 추가됨.
add_age는 save_path, name을 가짐.
리턴하면 state에 save_path, name, age 추가됨.
add_address는 save_path, name, age를 가짐.
리턴하면 state에 save_path, name, age, address가 추가됨.
save_info에 name, age, address를 저장.

노드 ->  노드
      <-

반복 : 두 노드간 서로 왔다갔다하면서 특정 조건을 만족할 때 까지 일을 처리
분기 : A -> B
	   -> C
A가 B로 가거나 C로 갈 수 있다.

add_conditional_edge( # 파라미터 3개 받음
llm_answer : 소스노드
결과를 조건 함수 노드로 보내줌. 
grounded가 리턴되면 END로 가라.
not_groundeed가 리턴되면 retrieve로 가라. retrieve가 아니고 llm_answer면 반복되는 구조임.

def relevance_check():
	if 
		return "노드이름"
	else
		return "노드이름"
노드의 이름을 리턴함.

llm->응답->종료
    ->tool_call->tool호출->ToolMessage
llm<-------------------------
   다시 툴콜 부를수도 있음. 이러면 반복.
그러다가 툴메세지에서 응답이 오면 종료.

함수안에 클래스 정의 가능.
함수안에 함수 가능.

create_agent() 가 랭그래프로 구현된거임.

state는 응답하면 사라짐. invoke 호출해서 invoke 사라질 때까지.
공유할 데이터가 state에 저장됨.

랭그래프 메모리 관리:Checkpointer 저장소에 저장. 전체 state를 저장. 
---------
구글에서
runpod 검색.
가입.
account
billing
other 누르고 $20 눌러야됨
pay with card 해서 결제.


















